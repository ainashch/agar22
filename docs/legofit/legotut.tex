\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage[backend=biber,
  natbib=true,
  style=numeric,
  sorting=nyt]{biblatex}
\usepackage[letterpaper,margin=1in]{geometry}
\usepackage{verbatim,moreverb}
\usepackage{graphicx}
\addbibresource{defs.bib}
\addbibresource{arrpubs.bib}
\begin{document}
\title{A Legofit Tutorial}
\author{Alan R. Rogers}
\date{\today}
\maketitle

\section{Introduction}
This is a tutorial on Legofit, a package that uses genetic data to
estimate the history of population size, subdivision, and admixture
\citep{Rogers:BMC-20-526, Rogers:PCJ-2-e32}. The full documentation is
available
\href{http://alanrogers.github.io/legofit/html/index.html}{online}. It
will step you through the process of installing the software, using it
to create the input files used by the legofit program, and then
analyzing these data to fit a model of population history. We will
assume that data files are already available in .vcf format.

This tutorial will be used in the 2022 edition of the AGAR
Workshop. During the workshop, we will do only last step in this
process, which estimates population history from the frequencies of
nucleotide site patterns (explained below). We will not do the
preliminary steps, which tabulate these site pattern
frequencies. Nonetheless, this tutorial describes the whole process.

\section{Installing and Using Legofit}
\subsection{Install git if necessary}
You may have git already. To find out whether you do, type:
\begin{verbatim}
    type git
\end{verbatim}
On Mac or Linux, this will print the location of the executable git
file. If there is no such file, you'll get an error message saying
\texttt{type: git: not found}. In that case, install git:
\begin{verbatim}
    brew install git
\end{verbatim}

\subsection{Clone legofit}
Use git to clone Legofit onto your machine. This step will create a
subdirectory called ``legofit,'' which will contain the source
code. Before executing the command below, use the \texttt{cd} command
to move into the directory where you keep source code that other
people have written. I keep such code in a directory called
\texttt{distrib}, which I originally created by typing \texttt{mkdir
  distrib}. Having created such a directory, move into it by typing
\begin{verbatim}
    cd distrib
\end{verbatim}
Then clone legofit by typing:
\begin{verbatim}
    git clone git@github.com:alanrogers/legofit.git legofit
\end{verbatim}
This will create a directory called legofit. Use \texttt{cd} to move into it.

\subsection{Install a C compiler if necessary}
To see whether you have a C compiler already, type \texttt{type cc},
or \texttt{type gcc}, or \texttt{type clang}. You should get output like
\begin{verbatim}
    cc is /usr/bin/cc
\end{verbatim}
If you need to install a C compiler, there are several
alternatives. On a Mac, you can install Xcode from the App Store. Or
you can use Homebrew to install clang or gcc:
\begin{verbatim}
    brew install clang
\end{verbatim}
or
\begin{verbatim}
    brew install gcc
\end{verbatim}
On Linux, the command would be
\begin{verbatim}
    sudo apt-get install clang
\end{verbatim}
or
\begin{verbatim}
    sudo apt-get install gcc
\end{verbatim}

\subsection{Install ``make'' if necessary}
You will also need the program ``make,'' so type ``type make.'' If you
need to install, then
\begin{verbatim}
    brew install make
\end{verbatim}

\subsection{Set up a ``bin'' directory to hold executable files.}
On Unix-like operating systems (MacOS and Linux) it is conventional
for each user to maintain a directory named "bin", just below the home
directory, which contains executable files. This directory must also
be added to the system's PATH variable, which is used for finding
executable files.

First create a ``bin'' directory, if you don't already have one. To do
so, first type the command
\begin{verbatim}
    cd
\end{verbatim}
at the shell prompt. This moves you into your home directory. Then
type
\begin{verbatim}
    mkdir bin
\end{verbatim}
This creates a new directory called ``bin.''

You now need to add this to your shell's PATH variable. I'll assume
you're using the bash shell. In your home directory, look for a file
called either ``\verb|.bash_profile|'' or
``\texttt{.profile}''. Because the name begins with ``.'', it will not
show up if you type \texttt{ls}. However, it will appear if you type
\verb|ls .bash_profile| or \verb|ls .profile|. If only one of these
files exists, open it with a text editor (not a word processor). If
they both exist, edit ``\verb|.bash_profile|''. If neither exists, use
the editor to create a new file called ``\verb|.bash_profile|''.

Within this file, you may find existing definitions of the PATH
variable. Add the following after the last line that changes this
variable:
\begin{verbatim}
    export PATH=$HOME/bin:$PATH
\end{verbatim}
Save this change and exit the editor.

The contents of this file are executed by the shell each time you log
into your computer. Since you have just created the file, your PATH
has not yet been reset. Log out and then log back in again, and your
PATH should be set. To check it, type
\begin{verbatim}
    echo $PATH
\end{verbatim}
This will print your PATH.

\subsection{Compile and install legofit}
The details are in the
\href{http://alanrogers.github.io/legofit/html/index.html}{Legofit
  documentation}. 

\subsection{Soft links to group storage}
In the sections that follow, I will introduce you to several
directories and files on the CHPC servers. Each one is described by
its ``path name'' relative to your own ``home directory,'' which is
represented by the symbol \verb|~|. Before these path names will work,
you'll need to define two ``soft links'' within your own home
directory, which point to group storage devices owned by the Rogers
lab. After you define these soft links, \verb|~/grp1| will refer to
one of these group storage devices and \verb|~/grp2| to the other. You
can establish these links by typing
\begin{verbatim}
    ln -s /uufs/chpc.utah.edu/common/home/rogersa-group1 ~/grp1
    ln -s /uufs/chpc.utah.edu/common/home/rogersa-group2 ~/grp2
\end{verbatim}
If everyone in the lab defines these soft links in the same way, then
we can all use path names of the form
\verb|~/grp1/rogers/data/whatever|.

\subsection{Making an input file in .raf format}
Legofit uses data in ``.raf'' format. The following data sets are
already available on the server at Utah's CHPC.
\begin{description}
\item[Altai Neanderthal]
\verb|~/grp1/rogers/data/altai/orig2/altai.raf.gz|

\item[Vindija Neanderthal]
\verb|~/grp1/rogers/data/vindija/orig/vindija.raf.gz|

\item[Denisovan]
\verb|~/grp1/rogers/data/denisova/orig2/denisova.raf.gz|

\item[Western Europeans (SGDP)]
\verb|~/grp1/rogers/data/simons/raf/weur.raf.gz|
\end{description}
You can use any or all of these in your projects. But you'll also need
to make at least one more. To do so, copy the following
\href{https://alanrogers.github.io/agar22/legofit/weur.slr.html}{script}
into a directory of your own:
\begin{verbatim}
    ~/grp1/rogers/data/simons/raf/weur.slr
\end{verbatim}
Change its name (because ``weur'' stands for ``western European'') and
edit it to reflect the population or populations that you want to
study. It's set up to run on the ``notchpeak'' cluster, where I have
only one node.

If that node is free, you can run it there by using ``cd'' to move to
the directory that contains the script and then typing
\begin{verbatim}
    sbatch <your script name>
\end{verbatim}
where \verb|<your script name>| is the name of your version of the
script. This script will take many hours to complete. You can check on
its status at any time by typing
\begin{verbatim}
    squeue -u <your user id>
\end{verbatim}
where \verb|<your user id>| is the id you use to log onto the CHPC cluster.
As a shorthand, I often type this as
\begin{verbatim}
    squeue -u `whoami`
\end{verbatim}
which uses Linux's ``whoami'' command to fill in your user id.

If the notchpeak node is busy, try kingspeak instead. I have six nodes
there, so your odds are better. Before doing so, edit your slurm
script. The lines that read
\begin{verbatim}
    #SBATCH --account=rogersa-np
    #SBATCH --partition=rogersa-np
\end{verbatim}
work on notchpeak but not on kingspeak. For kingspeak, they should read
\begin{verbatim}
    #SBATCH --account=rogersa-kp
    #SBATCH --partition=rogersa-kp
\end{verbatim}

\subsection{Working with Legofit}
\subsubsection{Organizing the top-level directory for a Legofit project}
For each project, I create a directory tree with the same format,
which is illustrated in the github repository at
\href{https://github.com/alanrogers/agar22/tree/main/legofit/europe}{legofit/europe}.
The top-level directory contains the following files:
\begin{description}
\item[README.md]
Describes how all the other files in the directory were made.

\item[data.opf]
Observed site-pattern frequencies, as generated by Legofit's
``sitepat'' program, under the control of ``sitepat.slr.''

\item[boot]
A subdirectory containing bootstrap replicates, which have names
like ``boot0.opf,'' ``boot1.opf,'' and so on. These files are also
generated by ``sitepat,'' under the control of ``sitepat.slr.''

\item[\href{sitepat.slr.html}{sitepat.slr}]
A slurm script that runs ``sitepat'' and creates ``data.opf'' and all
the .opf files within subdirectory ``boot.''
\end{description}
Eventually, the top-level directory will contain other files, with
names like ``all.bootci'' and ``all.bma,'' which contain the results
of analyses.

Within the top-level directory, there should be a directory for each
model that is fit to the data in ``data.opf'' and ``boot/boot*.opf.''
Name these as you wish, but it's a good idea to keep the names
short. Mine tend to have names like ``a,'' ``b,'' ``ab,'' etc. The
``a'' directory contains a model in which there is only one episode of
admixture, labeled $\alpha$. The ``ab'' directory is for a model that
has episodes $\alpha$ and $\beta$.

\subsubsection{Tabulating site patterns}
The next step is to run sitepat, which reads a series of .raf files
and writes a file describing the frequency of each site
pattern. Optionally, it also writes a series of output files, each
describing site pattern frequencies in a different
\href{https://en.wikipedia.org/wiki/Bootstrapping_(statistics)}{bootstrap
  replicate}. These replicates are used for measuring statistical
uncertainty. Details are in the
\href{https://alanrogers.github.io/legofit/html/sitepat.html}{Legofit
  docs}. Sitepat reads enormous data files and can take hours to run,
even on a compute cluster. In this workshop, I'll do this step for
you.

Have a look at file
\href{https://github.com/alanrogers/agar22/blob/main/legofit/europe/data.opf}{data.opf}. After
the header, the first few lines look like
\begin{verbatim}
#       SitePat             E[count]           loBnd           hiBnd
              x       312922.8110121  311974.2398439  313732.1909228
              y       306301.1413693  305178.5610866  307121.6833708
              v       102039.5699405  101293.0904018  102887.7097098
              a        78653.9538690   77779.2808408   79467.4795387
              d       339489.6889881  337728.6566221  341531.9807664
            x:y       189532.2514885  187871.4715776  191321.2242190
\end{verbatim}
The left column lists the site patterns. ``E[count]'' is (more or
less) the number of sites exhibiting each site pattern. (For a full
explanation, see the
\href{https://alanrogers.github.io/legofit/html/index.html#sitepattern}{Legofit
  docs}.)


\subsubsection{Running legofit}
On the repo, look at directory
\href{https://github.com/alanrogers/agar22/tree/main/legofit/europe/a}{legofit/europe/a}. This
deals with a simple model, with only one episode of admixture. The
model of history is described in file
\href{https://github.com/alanrogers/agar22/tree/main/legofit/europe/a/a.lgo}{a.lgo},
using a syntax described in the
\href{https://alanrogers.github.io/legofit/html/index.html#lgo}{Legofit
  documentation}. You will want to write your own .lgo file, which
describes the model of history you want to study. But first, let's
do an exercise with this one.

Before attempting this exercise, you should have installed Legofit as
described above and cloned the agar22 repo onto your own
computer. Then use the terminal application to \texttt{cd} into
directory \texttt{legofit/europe/a} and type:
\begin{verbatim}
legofit -1 -d 0 --tol 1e-3 a.lgo ../data.opf
\end{verbatim}
After a few seconds, legofit should print a page of output. But before
examining that, let's unpack the command that generated it. The 1st
argument on the command line is ``\texttt{-1}.'' This tells legofit to
use singleton site patterns---those in which the derived allele is
present only once. Next, the arguments ``\texttt{-d 0}'' tells legofit
to use its deterministic algorithm, which is faster and more accurate
than the stochastic one it uses by default. (The stochastic algorithm
is needed for complex models.) The arguments ``\texttt{--tol 1e-3}''
tell legofit to be satisfied with a fairly loose fit between model and
data. In research, you would want a smaller number here. The next
argument, \texttt{a.lgo}, is the file describing the model of history,
and the final argument, \texttt{../data.opf}, is the data file.

\subsubsection{Studying a model of history}
For any given data set, you will want to study several models. It is
convenient to keep the files relating to a given model in a directory
just under the one that holds the data file. The directory for each
model contains the following files:
\begin{description}
  \item[\texttt{a.lgo}] describes the model of history
under study. The syntax of a .lgo file is described in the
\href{http://alanrogers.github.io/legofit/html/index.html#lgo}{legofit
  documentation}.
  \item[\texttt{a1.slr}] is a script, which can be interpreted by
    ``slurm,'' a program that manages jobs on a compute cluster. This
    file runs legofit on the real data.
  \item[\texttt{a1boot.slr}] a slurm script that runs legofit on a
    bootstrap replicate. This script is run once for each bootstrap
    replicate, using slurm's \texttt{sbatch --array} command.
  \item[\texttt{a2.slr}]
\end{description}    

\begin{verbatim}
sed -i "" 's/5000/100/g' *.sh 
\end{verbatim}

\printbibliography

\end{document}
